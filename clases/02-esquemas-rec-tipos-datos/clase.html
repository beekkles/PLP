<h2>Clase 2 - Esquemas de recursión y tipos de datos </h2>
<p><code>
map :: (a -&gt; b) -&gt; [a] -&gt; [b]
filter :: (a -&gt; Bool) -&gt; [a] -&gt; [a]

()

map filter :: [a] -&gt; Bool -&gt; [[a] -&gt; [a]]

</code></p>
<h2>Recursión estructural</h2>
<p>g no se puede llamar a si misma, ni a la cola de la lista salvo en el
caso que g se llame a la cola de la lista</p>
<p>Es <strong>recursión estructural</strong> si:</p>
<ul>
<li><p>Hay un caso base fijo de un valor z independiente de g</p></li>
<li><p>El caso recursivo no puede usar los parámetros g ni xs,</p></li>
</ul>
<p>salvo en la expresión (g xs)</p>
<h2>foldr, definición</h2>
<p><code>
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
foldr f [] = z
foldr f z (x:xs) = f x : (foldr f z xs)

</code></p>
<h2>Recursión primitiva</h2>
<p>Sea g :: [a] -&gt; b tal que: g [] = &lt; caso base &gt; g (x:xs) =
&lt; caso recursivo &gt;</p>
<p><span class="math inline">∑<sub><em>x</em></sub><em>f</em></span></p>
